# Android开发规范(V0.1)
[toc]
## 一、引言

### 1.1 何为代码规范？

代码规范是一种约定俗成的规范格式，由于每个开发语言的语法特色不同，因此不同开发语言的代码规范略有差异，本文仅针对 Android开发所用的Java及Kotlin等开发语言进行描述。

### 1.2 代码规范的作用？

任何一家公司进行规范开发时，首先要做的即是制定其代码规范，代码规范可以带给团队强大的正向效用，可用以下方面进行描述：

1. 统一代码风格，提高团队的编码效率，减少因代码风格而导致的代码冲突
2. 提高代码质量，增强代码运行效率，避免一些低级代码漏洞的出现
3. 提高代码可读性，增强代码的可维护性

### 1.3 代码规范的细化分

代码规范在大公司内部主要分为三个方面：代码风格、代码质量、Git管理。

### 1.4 PR审核机制

Pull Request拉取请求是规范流程中的重要一步，大规模项目通过此流程，剔除更多的不合规代码，把时间更多的花在构建上，而非维护上。

代码编写提交规范流程：**成员编写代码->自测及Review->Git提交代码至Fork代码库->建立合并请求->等待PR审查(机审代码规范，人工审核代码漏洞)->符合规范，准许合入**

## 二、代码风格

### 2.1命名规范

代码编写中经常要进行命名，好的命名规范可以快速的了解代码意图，在命名时要根据当前场景及属性含义来进行。

#### 2.1.1 局部变量

局部变量与参数变量使用小写驼峰式进行命名，单词拼接严格注意大小写，例如变量是“代码规范”的字符串。

```java
String codeStyle = "codeStyle";
```

#### 2.1.2静态属性变量

静态属性变量依然使用小写驼峰式，但变量名前使用小写字母s进行标记，说明当前变量为静态类型，例如变量是“代码规范”的字符串

```kotlin
static String sCodeStyle = "codeStyle";
```

#### 2.1.3 全局属性变量

全局属性变量依然使用小写驼峰式，但变量名前使用小写字母m进行标记，说明当前变量为全局类型，例如变量是“代码规范”的字符串。

```java
private String mCodeStyle = "codeStyle";
```

#### 2.1.4常量属性

常量属性使用大写下划线分割式，说明为常量不可变类型，如果为静态常量，那么static关键字必须在final关键字前面，例如常量是“代码规范”的字符串。

```java
/**
 * 普通常量
 */
private final String CODE_STYLE = "codeStyle";
/**
 * 静态常量
 */
public static final String CODE_STYLE = "codeStyle";
```

#### 2.1.5函数命名

函数命名使用小写驼峰式，根据函数功能对函数进行命名，命名要清晰直观，例如获取字符串“代码规范”的函数

```java
public String getCodeStyleStr() {
  return "codeStyle"
}
```

#### 2.1.6 包命名

包命名使用小写下划线分割式，根据模块功能对包进行命名，命名要清晰直观。

**根目录命名**

项目根目录一般使用com或cc开头，后面是公司名，然后接着项目名，最后是模块名。

示例：com.txznet.core.app

#### 2.1.7 类及接口命名

类及接口命名使用大写驼峰式，根据类或接口的功能进行命名，命名要清晰明确。

实体类示例:

```java
public class ReponseBean {

}
```

### 2.2 注释

注释非常关键，对后续代码的维护性起到很重要的作用，注释主要分为DOC注释与行注释。

**DOC注释**

属性、函数、类、接口只能使用DOC注释，函数如果有参数和返回值，必须标明参数及返回值的含义。

**行注释**

函数内部使用行注释，但禁止使用行尾注释，行注释的对象为注释下方的代码。

> 行注释//与说明之间要留一个空格，提高注释可读性，如// 此为注释示例

**示例标准：**

```java
/**
 * @author 作者
 * Create Date 2022-07-01
 */
public class TestBean {
  /**
   * 姓名
   */
  private String mName;
  
  /**
   * 获取名字
   * @return 名字
   */
  public String getName() {
    if (mName==null) {
      // 如果名字为 null，那么就返回空字符串
      return "";
    }
    retutn mName;
  }
  
  /**
   * 设置名字
   * @param 名字
   */
  public void setName(String name) {
    mName = name;
  }
}
```

### 2.3 代码空隙

编写代码时需要有一定的空隙，代码空隙可以提高可读性，例如等号两边需要留有一个空格的空隙，函数之间需要一个空行的空隙。

代码空隙可以通过Android Studio一键格式化来规范。

代码空隙有以下注意点：

1. 禁止连续空行
2. 函数的头尾不要有空行

### 2.4 代码摆放顺序

禁止在任意位置声明变量、常量及函数等，代码需要按照常量、变量、函数的一定规则顺序进行摆放(可通过Android Studio一键调整代码顺序)，排列顺序按优先级如下：

**Java语言**

1. 静态代码块
2. 静态常量属性
3. 静态变量属性
4. 常量属性 
5. 全局属性
6. 构造器
7. 代码块
8. 静态函数
9. 函数
10. 枚举内部类
11. 接口内部类
12. 静态内部类
13. 内部类

**Kotlin语言**

按照Google官方规范，Android Studio一键格式化即可

### 2.5 代码字数上限

代码字数过长或行数过多都会影响代码可读性，短小且简单的代码更容易理解和复用，同时会提高函数的运行效率，因此规定其上限字数和行数量。

#### 2.5.1 函数行数上限

一个函数最多不能超过50行，使用函数单一职责创建新函数进行精简，若有无法拆分的函数可超过上限但最高不可高于上限的3倍，同时注释不计算在代码行数之中。

#### 2.5.2 代码横向字数上限

编写代码时，横向代码最多为120字符，若超过120字符则另起一行。另起一行时仅可以在以下字符截断：

> =、-、+、*、/、()、&、&&、|、||、，、{}

## 三、代码质量

### 3.1 单一职责

单一职责是程序设计中的最基本准则，一个类或函数只承担一个责任，简化责任的好处是可复用性增强，类和函数的职责清晰易理解。

#### 3.1.1 类的单一职责

一个类仅可有一个的模块功能，类中所有属性、函数都只能和此模块功能相关，禁止God Class的出现。

#### 3.1.2 函数的单一职责

一个函数仅可有一个功能逻辑，函数中可以调用其他逻辑的函数，但禁止把多个逻辑混合到一个函数中编写。

### 3.2 禁止魔法值

在代码中未经声明而使用的**<u>临时整数、浮点数、不易理解的字符串</u>**均被称为魔法值，魔法值经常需要反复研读代码和熟悉业务才可能明白其含义，因此魔法值的存在大大降低了代码可读性和可维护性。

魔法值示例：

```java
public String getType(int type) {
  if (type==0) {
    return "0";
  }
  switch (type) {
    case 1:
      return "1";
    case 2:
      return "2";
  }
}
```

### 3.3 if逻辑判断

if逻辑判断是编写代码中使用频率非常高的，使用不当便会造成代码可读性差，代码运行效率低的问题。

典型反面范例：如GTA5联机版一个if语句竟然要跑19.8亿次，导致cpu占用过高，联机速度过慢，国外大佬逆向修改优化后，速度提高70%，cpu使用降低50%。

那么针对if判断，该如何做优化，从多条件简化和嵌套优化开始。

#### 3.3.1 多条件简化

开发中经常会遇到，一个if判断需要多个条件，导致编写代码时，一个if判断的逻辑都要好几行，反面示例：

```java
if((a!=null && a.getA()!=null) || (s!=null && s.getS()!=null) && (b!=null || c!=null)) {
  
}
```

因为if在执行时，虚拟机会根据条件一个一个的去运算执行，每一次执行都会重复运算，效率非常低。

针对这种多条件判断，就需要进行简化，**第一种思路：**

首先将条件判断转化函数(注意函数的单一职责)，然后再将条件用函数来代替。示例如下：

```java
public boolean isANotNull() {
  return a!=null && a.getA()!=null;
}

public boolean isSNotNull() {
  return s!=null && s.getS()!=null;
}

public boolean isBNotNull() {
  return b!=null;
}

public boolean isCNotNull() {
  return c!=null;
}

if(isANotNull() || isSNotNull() && (isBNotNull() || isCNotNull())) {
  
}
```

这样写看起来只是把条件抽取为函数，并没有什么不同，但在执行效率上，这种方式在循环或高频次调用中会大幅度提高，因为函数在运行后，虚拟机栈会短暂保留计算结果，在高频次调用中，计算结果就可以进行重用，从而提升运行效率。

另外将条件抽取为函数，也可以在其他地方判断时，复用判断逻辑代码。

**第二种思路：**

使用Map存储运算结果，并从Map中取值进行判断。

#### 3.3.2 嵌套层级上限

编写代码时，经常遇到if判断有先后顺序，因此就产生了很多层级的if判断，反面示例：

```java
if(条件1) {
	if(条件2) {
    if(条件3) {
      if(条件4) {
        if(条件5) {
          if(条件6) {
            
          }
        }
      }
    }
  }
}
```

这样的代码会大大降低代码可阅读性和维护性,**<u>我们约定if嵌套层级最高不超过3层</u>**，当超过时可通过以下三种思路进行优化：

1. 通过状态模式将if判断分配到对应接口子类中，从而实现简化嵌套

2. 对象的取值判断，可通过Map简化条件判断

3. 将嵌套层级变为平级

   ```java
   if(条件1) {
     return;
   }
   if(条件2) {
    return 
   }
   if(条件3) {
     return;
   }
   ```

### 3.4 switch case的优化

switch case也是常用的分支判断，虽然通常情况下，比if的运行效率要高，但是当case过多时，同样会影响代码可读性和维护性，<u>**我们约定switch case的数量最大不超过10个**</u>，超过时可以通过参考if优化思路：

1. 对象创建获取的分支逻辑，可用Map进行优化
2. 使用工厂和抽象工厂模式进行优化
3. 将case中的逻辑抽取为函数，提高代码可读性。

### 3.5 Callback Hell(回调地狱)的优化

类似if嵌套，在代码中经常有一些异步逻辑监听回调，比如网络请求的回调，网络请求串行，代码中出现的请求回调嵌套，或者Handle的post回调嵌套等。

但回调的嵌套层级超过一定层级，也会造成代码可读性及运行效率降低，<u>**我们约定回调嵌套层级最大不超过2层**</u>，当超过两层时就要进行优化，思路如下：

1. 将匿名回调函数或匿名类变为声明函数或声明类，提高复用性。
2. 使用任务队列进行优化，将回调变为任务，并通过任务管理器进行管理。

### 3.6 枚举与静态常量

先说结论，由于Android的内存大小及Cpu性能影响，<u>**在Android中更推荐使用静态常量并配合@xxxDef注解来替换枚举的使用**</u>，示例如下：

```java
    // 定义仅支持男人和女人的类型。
    @Retention(RetentionPolicy.SOURCE)
 		@Target({
            ElementType.PARAMETER,
            ElementType.FIELD,
            ElementType.METHOD,
    })
    @IntDef({MAN , WO_MAN})
    private  @interface SEX_TYPE{}

    public static final int MAN = 1;
    public static final int WO_MAN = 2;

    public @SEX_TYPE int type;
    public void setSex(@SEX_TYPE int type) {
        this.type = type;
    }
```

**枚举不推荐使用的说明：**

在编写代码时，枚举类是我们经常会遇到的，但在Android官方文档推出[性能优化](https://link.zhihu.com/?target=https%3A//developer.android.com/topic/performance/)的时候，从一开始有这样一段说明(现已删除)：

> Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.

意思是说在Android平台上**avoid**使用枚举，因为枚举类比一般的静态常量多占用两倍的空间。

> 如果你还不了解枚举，参看文章[枚举介绍以及枚举的本质](https://link.zhihu.com/?target=https%3A//gudong.name/2019/11/08/enum-introduce.html)。

由于枚举最终的实现原理还是类，在编译完成后，最终为每一种类型生成一个静态对象，而在内存申请方面，对象需要的内存空间远大于普通的静态常量，而且分析枚举对象的成员变量可知，每一个对象中默认都会有一个字符数组空间的申请，计算下来，枚举需要的空间远大于普通的静态变量。

**但在开启ProGuard优化的情况下，枚举会被转为基础类型**，所以理论上内存占用问题是可以忽略的。具体可参看ProGuard的优化列表页面 [Optimizations Page](https://link.zhihu.com/?target=http%3A//proguard.sourceforge.net/manual/optimizations.html)，其中就列举了enum被优化的项，如下所示：

> class/unboxing/enum
> Simplifies enum types to integer constants, whenever possible.

虽然枚举已经由编译器做了一定优化，但并不是说枚举就可以随意使用，ProGuard对枚举的优化有一定的限制条件，如果枚举类存在如下的情况，将不会有优化为基础类型，如下所示：

1. 枚举实现了自定义接口。并且被调用。
2. 代码中使用了不同签名来存储枚举。
3. 使用 instanceof 指令判断。
4. 在枚举加锁操作。
5. 对枚举强转。
6. 在代码中调用静态方法 valueOf 方法。
7. 定义可以外部访问的方法。

也就是说，要保证枚举能被正常优化为整形，就要确保枚举足够简单，如下所示，这种类似情况下的枚举是可以被优化的

```java
enum Color {
  Red,Black,Green
}
```

再次查看那七条规则，会发现这几个规则几乎把枚举面向对象的特性都限制了，在这样的限制下，枚举好用的地方都将消失，失去了枚举的灵活性。

### 3.7 空判断

空指针是开发时最常遇到的异常，但是空指针是完全可以避免的。

开发时当变量可能为null时，一定要做判空处理，或者Java8下使用Optional类进行空判断处理。Kotlin的话使用变量?的形式避免空指针，或者if判空、高阶函数处理等。

### 3.8 对象的创建与释放

对象的合理创建和释放可以增强内存管理，提高代码运行效率。虽然Jvm有GC来管理对象生命周期，但是当使用不当时，依然会造成很多问题。

#### 3.8.1 对象池的使用

在一些频繁创建对象的场景，通过对象池进行复用优化，可以减少内存占用，提高对象创建效率。

典型示例：RecyclerView的viewPool，Glide的LruCache

#### 3.8.2 禁止循环内创建对象

循环内部创建对象，会导致短时间内创建了大量临时对象，当函数执行完后，这些对象都将被GC回收，GC在回收对象时会占用大量的CPU，因此导致内存抖动，甚至造成ANR和内存溢出，可使用对象池优化。

#### 3.8.3 生命周期的对象创建与销毁

在Activity或Framgment等生命周期初始创建的全局对象，如果不会自动销毁，并且存在内存泄漏风险，必须在生命周期结束时手动进行销毁。

#### 3.8.4 避免内存泄露

内存泄漏的本质是，类和类中的属性生命周期不一致时，当外部类被销毁，但是内部属性依然持有其引用，便会导致JVM不会及时回收，从而造成内存泄漏。

Android中内存泄漏的示例如下：

1. 使用Handler的匿名内部类，并且没有将Handler设置为静态，Handler执行post或sendMessage后的内存泄漏。
2. Bitmap对象使用完毕后没有recyle()，导致图像数据未释放。
3. 自定义View时，TypedArray使用完毕后，没有recyle()，导致资源数据未释放。
4. 页面类中使用单例，导致一直被持有无法释放。
5. 非静态内部类创建的静态属性实例，导致一直被持有无法释放。
6. 线程运行时持有类对象，类销毁时，导致一直被持有无法释放。

#### 3.8.5 避免内存溢出(OOM)

Android中分配给某一个进程的内存大小是有限的，当超过这个值，就会内存溢出并抛出OOM异常。

内存溢出优化思路如下：

1. 禁止短时间内频繁创建对象
2. 加载大对象时，通过缓冲流的方式进行读取
3. 减少递归层级
4. 及时释放对象资源

### 3.9 线程的规范使用

线程是异步工作的必要工具，但是关于线程开发，若不遵守一定的规范，则会导致线程执行效率低，对象锁不正确，内存及CPU占用高等问题。

#### 3.9.1 线程池的使用

在开发中，直接用new Thead的方式创建线程，不利于进行线程管理，并且当大量创建线程后，还会对cpu和内存造成很大负担。

因此在开发中严格禁止new Thread的方式创建线程，必须使用线程池进行创建。

#### 3.9.2 同步对象锁

在使用synchronized修饰对象时，一定注意锁的是Class对象还是实例对象，如果是Class对象那么整个Class对象共用一把锁，如果锁的是实例对象，那么实例对象是单独一把锁。

推荐synchronized修饰实例对象(本类对象或类中属性对象)，而不是Class对象。

在开发中，严格注意synchronized修饰的必须是同一个对象，否则可能导致锁的释放异常或无法锁住等问题，出现死锁、数据异常等现象。

> 典型范例：
>
> synchronized修饰普通的String对象时，因String存在于常量池的缘故，那么会造成锁异常。可通过String.intern()函数创建String对象，这样锁的String对象就是同一个对象。

#### 3.9.3 Concurrent类使用

针对异步调用，一些基础类型，Java1.5以后提供了Concurrent包进行调用，在异步开发中，可以使用Concurrent包下的类进行开发。

Concurrent包下的类示例：

- ConcurrentHashMap
- ArrayBlockingQueue
- AtomicInteger
- AtomicBoolean

### 3.10 代码封装

代码封装可以提高代码的可读性、复用性和维护性，良好的代码封装能让代码责任清晰易理解。

#### 3.10.1 访问修饰符

除sdk中同包下访问且不暴漏接口的情况，其他情况下均需要访问修饰符进行修饰。

全局属性仅可以使用private和protected修饰，通过get、set进行获取和赋值。

静态属性和静态函数分情况，如果仅本类使用(此情况最好不要用静态)，那么用private修饰，如果给多个类使用，那么就用public修饰。

全局函数可根据是否对外暴漏，使用private、protected、public进行修饰。

### 3.11 禁止import整个包

开发时经常为了方便，将整个包的类全部import到类中，但这样会导致没有用到的类也被加入类文件中，增大类文件的体积大小，因此用到哪个类单独导入哪个类，禁止import xx.*，导入整个包的类文件。

### 3.12 递归的规范使用

递归是非常基础且巧妙的一种算法思想，递归的本质是通过逻辑内敛，并不断减小问题规模，最终得出想要的结果。

例如通过递归查找对应文件夹下的文件，是按照文件夹->子文件夹->文件逐级进行查找，将问题结果逐渐缩小，最终找到目标文件。

但递归需要注意以下问题：

1. 递归函数的逻辑必须短小精炼，不可有大量占用内存的逻辑
2. 递归的内存占用
3. 递归条件的正确性

#### 3.12.1 递推的内存占用

由于函数递归是不断的调用其本身函数，并依赖上一次结果，因此函数调用栈内的函数对象会一直增加，因此会导致内存的不断增加。

如果递归逻辑中存在占用内存的逻辑，则很容易OOM。

递归层级过深也会导致函数执行效率低，甚至虚拟机栈溢出，<u>**因此规定递归层级最大不超过6层，如果超过请使用循环进行优化**</u>。

因此递归虽然巧妙，但使用不当也会造成内存问题。

#### 3.12.2 递归条件的正确性

递归条件必须设置终止条件，否则将会死循环并最终虚拟机栈溢出。

### 3.13 资源文件使用

#### 3.13.1资源命名规范

不同的资源文件需要遵循资源命名规范，规范如下：

1. 图标资源使用ic作为前缀，标识为是一个icon图标
2. 图片资源使用img作为前缀，标识为是一个image图片
3. 音频资源使用audio作为前缀，标识为是一个音频文件
4. 视频资源使用video作为前缀，标识为是一个视频文件

如果有多个module，module中的资源文件需要再次添加module的前缀，区分是不同module的资源。

#### 3.13.2资源文件压缩

开发中资源文件是常使用到的，大多数开发资源文件都是可以进行压缩的，如果图片、视频、音频等，当如果不对资源文件进行压缩就会导致安装包体积过大。

安装包过大会影响网络下发，导致系统内存占用过大等，进而影响业务发展。

#### 3.13.3 图片、SVG与Shape

在开发中，图像资源使用优先级：

1. 能够用shape实现的，尽量用shape来做
2. 小巧的图标使用svg加载
3. 其他图片如果不需要透明度，一律使用jpge或者webp，最后才使用png

### 3.14 日志规范

由于公司业务较为特殊，需要经常使用日志进行问题定位，因此日志的规范性就变得格为重要。

#### 3.14.1 日志输出

在代码中禁止使用System.print.out()输出日志，必须使用Log类进行输出。

正式发布的release apk安装包，默认情况下禁止输出业务数据的日志，避免业务信息的泄露(实车调试可通过本地文件配置开启Log输出)。

#### 3.14.2 日志等级

描述类的日志使用Verbose级别，调试类的使用Debug级别，信息数据类的使用Info级别，警告类的使用Wran级别，异常崩溃类的使用Error级别。

#### 3.14.3 日志不得包含敏感信息

输出的日志当中仅可以包含相关业务数据，禁止包含用户及公司的敏感信息，如用户名及密码、银行卡号及密码、公司信息等，如需打印日志请将信息脱敏。

### 3.15 异常规范

#### 3.15.1 业务代码的异常捕获

代码片段中如果判断可能存在异常，那么建议使用try{}catch(){}finally{}进行异常捕获，提高代码的健壮性。

异常捕获的原则主要基于业务逻辑是否会受异常影响，是否会导致用户的体验感变差。

#### 3.15.2 全局的异常捕获

全局的异常在Android中使用UncaughtExceptionHandler进行捕获，捕获后将异常堆栈信息及需要上报的信息发送至后台，便于项目统计异常率。

## 四、Git管理

### 4.1 分支命名

分支名称要根据意图来命名，例如需求的分支就根据需求来命名，优化的分支就根据优化事项来命名，修改bug的分支就根据bug名称来命名。

### 4.2 分支管理

一个分支创建完成后，要文档记录分支含义，在分支使用完毕后，要及时合并代码到主线分支，或者废弃分支将其删除。

### 4.3 commit代码规范

commit代码时，需要遵循一定的规范，这样在代码回滚或寻找某一次提交时，能够更方便查找，对库代码管理起到回朔作用。

目前后台已经将gitlab与tapd平台进行了整合，日后提交代码从gitlab可以直接访问tapd的需求单或bug单，tapd上也可以看到本需求或bug的git提交记录。

#### 4.3.1 单次commit的单一职责

每一次提交只解决一个问题，这样可以很容易发现漏提交的代码，并且方便回滚到对应提交。

#### 4.3.2 单次commit的代码数上限

每次commit提交的代码不要过多，和单一职责一样，单次提交的代码越少，越容易进行代码检查，方便回滚到对应的提交。

单次commit的代码数最高不超过500行，文件位置变更、资源文件增删等不计算。

#### 4.3.3 commit的message格式

为了方便回朔代码，commit的message的格式强制规定为以下三种：

1. 修复漏洞则用"fix：xxx tapd-bug单的源码提交关键字"进行提交。
2. 需求代码则用"feat：xxx tapd-需求单的源码提交关键字"进行提交。
3. 优化代码等杂项则用"mix:xxx"进行提交。

